// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimDue = `-- name: ClaimDue :many
with cte as (
   select id from alerts
  where status in ('pending', 'queued') and visible_at <= now()
  order by created_at
  for update skip locked
  limit $2
)
update alerts a
set status='processing',
    locked_at=now(),
    locked_by=$1,
    processing_deadline=now() + interval '30 seconds'
from cte
where a.id = cte.id
returning a.id, a.plate_id, a.hotlist_id
`

type ClaimDueParams struct {
	WorkerID pgtype.Text
	Batch    int32
}

type ClaimDueRow struct {
	ID        int64
	PlateID   int64
	HotlistID int64
}

func (q *Queries) ClaimDue(ctx context.Context, arg ClaimDueParams) ([]ClaimDueRow, error) {
	rows, err := q.db.Query(ctx, claimDue, arg.WorkerID, arg.Batch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClaimDueRow
	for rows.Next() {
		var i ClaimDueRow
		if err := rows.Scan(&i.ID, &i.PlateID, &i.HotlistID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ingestALPR = `-- name: IngestALPR :one
select public.ingest_alpr($1::jsonb) as result
`

func (q *Queries) IngestALPR(ctx context.Context, doc []byte) (string, error) {
	row := q.db.QueryRow(ctx, ingestALPR, doc)
	var result string
	err := row.Scan(&result)
	return result, err
}

const insertHotlist = `-- name: InsertHotlist :one
select hotlists_upsert_pois($1::jsonb) as added
`

func (q *Queries) InsertHotlist(ctx context.Context, doc []byte) (int32, error) {
	row := q.db.QueryRow(ctx, insertHotlist, doc)
	var added int32
	err := row.Scan(&added)
	return added, err
}

const nextWake = `-- name: NextWake :one
select least(
    coalesce((select min(visible_at) as wake from alerts
             where status in ('pending', 'queued') and visble_at > now()), 'infinity'),
            (select next_due_at from hotlist_alert_state where id=1))
`

func (q *Queries) NextWake(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, nextWake)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const reclaimStuck = `-- name: ReclaimStuck :one
select alerts_reclaim_stuck()
`

func (q *Queries) ReclaimStuck(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, reclaimStuck)
	var alerts_reclaim_stuck int32
	err := row.Scan(&alerts_reclaim_stuck)
	return alerts_reclaim_stuck, err
}

const scheduleFailure = `-- name: ScheduleFailure :exec
select hostlist_alert_schedure_failure($1, $2)
`

type ScheduleFailureParams struct {
	ID  interface{}
	Err interface{}
}

func (q *Queries) ScheduleFailure(ctx context.Context, arg ScheduleFailureParams) error {
	_, err := q.db.Exec(ctx, scheduleFailure, arg.ID, arg.Err)
	return err
}

const scheduleSuccess = `-- name: ScheduleSuccess :exec
select hotlist_alert_schedule_success($1)
`

func (q *Queries) ScheduleSuccess(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, scheduleSuccess, id)
	return err
}
