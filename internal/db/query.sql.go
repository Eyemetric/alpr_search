// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimDue = `-- name: ClaimDue :many
SELECT
    t.id::bigint as id,
    t.plate_id::bigint as plate_id,
    t.hotlist_id::bigint as hotlist_id
FROM alpr_util.claim_due($1::integer , $2::text) AS t(id bigint, plate_id bigint, hotlist_id bigint)
`

type ClaimDueParams struct {
	Batch    int32
	WorkerID string
}

type ClaimDueRow struct {
	ID        int64
	PlateID   int64
	HotlistID int64
}

func (q *Queries) ClaimDue(ctx context.Context, arg ClaimDueParams) ([]ClaimDueRow, error) {
	rows, err := q.db.Query(ctx, claimDue, arg.Batch, arg.WorkerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClaimDueRow
	for rows.Next() {
		var i ClaimDueRow
		if err := rows.Scan(&i.ID, &i.PlateID, &i.HotlistID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlateHit = `-- name: GetPlateHit :many
SELECT
    h.hotlist_id AS ID,
    'eyemetric' AS eventID,
    a.read_time AS eventDateTime,
    h.plate_number AS plateNumber,
    a.plate_code AS plateSt,
    '' AS plateNumber2,
    '' AS confidence,
    a.make AS vehicleMake,
    '' AS vehicleModel,
    a.color AS vehicleColor,
    '' AS vehicleSize,
    a.vehicle_type AS vehicleType,
    '' AS cameraID,
    a.camera_name AS cameraName,
    'Fixed' AS cameraType,
    'East Hanover Township Police Department' AS agency,
    '' AS ori,
    0.0 AS latitude,
    0.0 AS longitude,
    '' AS direction,
    '' AS imageVehicle,
    '' AS imagePlate,
    '' AS additionalImage1,
    '' AS additionalImage2
    FROM alpr a join hotlists h on a.plate_num = h.plate_number
  where a.id = $1::bigint and h.id = $2::bigint
`

type GetPlateHitParams struct {
	PlateID   int64
	HotlistID int64
}

type GetPlateHitRow struct {
	ID               string
	Eventid          string
	Eventdatetime    pgtype.Timestamp
	Platenumber      string
	Platest          pgtype.Text
	Platenumber2     string
	Confidence       string
	Vehiclemake      pgtype.Text
	Vehiclemodel     string
	Vehiclecolor     pgtype.Text
	Vehiclesize      string
	Vehicletype      pgtype.Text
	Cameraid         string
	Cameraname       pgtype.Text
	Cameratype       string
	Agency           string
	Ori              string
	Latitude         float64
	Longitude        float64
	Direction        string
	Imagevehicle     string
	Imageplate       string
	Additionalimage1 string
	Additionalimage2 string
}

func (q *Queries) GetPlateHit(ctx context.Context, arg GetPlateHitParams) ([]GetPlateHitRow, error) {
	rows, err := q.db.Query(ctx, getPlateHit, arg.PlateID, arg.HotlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlateHitRow
	for rows.Next() {
		var i GetPlateHitRow
		if err := rows.Scan(
			&i.ID,
			&i.Eventid,
			&i.Eventdatetime,
			&i.Platenumber,
			&i.Platest,
			&i.Platenumber2,
			&i.Confidence,
			&i.Vehiclemake,
			&i.Vehiclemodel,
			&i.Vehiclecolor,
			&i.Vehiclesize,
			&i.Vehicletype,
			&i.Cameraid,
			&i.Cameraname,
			&i.Cameratype,
			&i.Agency,
			&i.Ori,
			&i.Latitude,
			&i.Longitude,
			&i.Direction,
			&i.Imagevehicle,
			&i.Imageplate,
			&i.Additionalimage1,
			&i.Additionalimage2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ingestALPR = `-- name: IngestALPR :one
select alpr_util.ingest_alpr($1::jsonb) as result
`

func (q *Queries) IngestALPR(ctx context.Context, doc []byte) (string, error) {
	row := q.db.QueryRow(ctx, ingestALPR, doc)
	var result string
	err := row.Scan(&result)
	return result, err
}

const insertHotlist = `-- name: InsertHotlist :one
select alpr_util.hotlists_upsert_pois($1::jsonb) as added
`

func (q *Queries) InsertHotlist(ctx context.Context, doc []byte) (int32, error) {
	row := q.db.QueryRow(ctx, insertHotlist, doc)
	var added int32
	err := row.Scan(&added)
	return added, err
}

const nextWake = `-- name: NextWake :one
select alpr_util.next_wake()
`

func (q *Queries) NextWake(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, nextWake)
	var next_wake interface{}
	err := row.Scan(&next_wake)
	return next_wake, err
}

const reclaimStuck = `-- name: ReclaimStuck :one
select alpr_util.alerts_reclaim_stuck()
`

func (q *Queries) ReclaimStuck(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, reclaimStuck)
	var alerts_reclaim_stuck int32
	err := row.Scan(&alerts_reclaim_stuck)
	return alerts_reclaim_stuck, err
}

const scheduleFailure = `-- name: ScheduleFailure :exec
select alpr_util.hostlist_alert_schedure_failure($1, $2)
`

type ScheduleFailureParams struct {
	ID  interface{}
	Err interface{}
}

func (q *Queries) ScheduleFailure(ctx context.Context, arg ScheduleFailureParams) error {
	_, err := q.db.Exec(ctx, scheduleFailure, arg.ID, arg.Err)
	return err
}

const scheduleSuccess = `-- name: ScheduleSuccess :exec
select alpr_util.hotlist_alert_schedule_success($1)
`

func (q *Queries) ScheduleSuccess(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, scheduleSuccess, id)
	return err
}
