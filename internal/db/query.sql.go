// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
)

const claimDue = `-- name: ClaimDue :many
SELECT
    t.id::bigint as id,
    t.plate_id::bigint as plate_id,
    t.hotlist_id::bigint as hotlist_id
FROM alpr_util.claim_due($1::integer , $2::text) AS t(id bigint, plate_id bigint, hotlist_id bigint)
`

type ClaimDueParams struct {
	Batch    int32
	WorkerID string
}

type ClaimDueRow struct {
	ID        int64
	PlateID   int64
	HotlistID int64
}

func (q *Queries) ClaimDue(ctx context.Context, arg ClaimDueParams) ([]ClaimDueRow, error) {
	rows, err := q.db.Query(ctx, claimDue, arg.Batch, arg.WorkerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClaimDueRow
	for rows.Next() {
		var i ClaimDueRow
		if err := rows.Scan(&i.ID, &i.PlateID, &i.HotlistID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ingestALPR = `-- name: IngestALPR :one
select alpr_util.ingest_alpr($1::jsonb) as result
`

func (q *Queries) IngestALPR(ctx context.Context, doc []byte) (string, error) {
	row := q.db.QueryRow(ctx, ingestALPR, doc)
	var result string
	err := row.Scan(&result)
	return result, err
}

const insertHotlist = `-- name: InsertHotlist :one
select alpr_util.hotlists_upsert_pois($1::jsonb) as added
`

func (q *Queries) InsertHotlist(ctx context.Context, doc []byte) (int32, error) {
	row := q.db.QueryRow(ctx, insertHotlist, doc)
	var added int32
	err := row.Scan(&added)
	return added, err
}

const nextWake = `-- name: NextWake :one
select alpr_util.next_wake()
`

func (q *Queries) NextWake(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, nextWake)
	var next_wake interface{}
	err := row.Scan(&next_wake)
	return next_wake, err
}

const reclaimStuck = `-- name: ReclaimStuck :one
select alpr_util.alerts_reclaim_stuck()
`

func (q *Queries) ReclaimStuck(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, reclaimStuck)
	var alerts_reclaim_stuck int32
	err := row.Scan(&alerts_reclaim_stuck)
	return alerts_reclaim_stuck, err
}

const scheduleFailure = `-- name: ScheduleFailure :exec
select alpr_util.hostlist_alert_schedure_failure($1, $2)
`

type ScheduleFailureParams struct {
	ID  interface{}
	Err interface{}
}

func (q *Queries) ScheduleFailure(ctx context.Context, arg ScheduleFailureParams) error {
	_, err := q.db.Exec(ctx, scheduleFailure, arg.ID, arg.Err)
	return err
}

const scheduleSuccess = `-- name: ScheduleSuccess :exec
select alpr_util.hotlist_alert_schedule_success($1)
`

func (q *Queries) ScheduleSuccess(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, scheduleSuccess, id)
	return err
}
