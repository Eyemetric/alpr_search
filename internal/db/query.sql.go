// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimDue = `-- name: ClaimDue :many
SELECT
    id::bigint as id,
    plate_id::bigint as plate_id,
    hotlist_id::bigint as hotlist_id
FROM alpr_util.claim_due($1::integer , $2::text)
`

type ClaimDueParams struct {
	Batch    int32  `json:"batch"`
	WorkerID string `json:"workerID"`
}

type ClaimDueRow struct {
	ID        int64 `json:"id"`
	PlateID   int64 `json:"plateID"`
	HotlistID int64 `json:"hotlistID"`
}

func (q *Queries) ClaimDue(ctx context.Context, arg ClaimDueParams) ([]ClaimDueRow, error) {
	rows, err := q.db.Query(ctx, claimDue, arg.Batch, arg.WorkerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ClaimDueRow{}
	for rows.Next() {
		var i ClaimDueRow
		if err := rows.Scan(&i.ID, &i.PlateID, &i.HotlistID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlateHit = `-- name: GetPlateHit :many
SELECT
    h.hotlist_id AS ID,
    'eyemetric' AS eventID,
    a.read_time AS eventDateTime,
    h.plate_number AS plateNumber,
    a.plate_code AS plateSt,
    '' AS plateNumber2,
    '' AS confidence,
    a.make AS vehicleMake,
    '' AS vehicleModel,
    a.color AS vehicleColor,
    '' AS vehicleSize,
    a.vehicle_type AS vehicleType,
    '' AS cameraID,
    a.camera_name AS cameraName,
    'Fixed' AS cameraType,
    'East Hanover Township Police Department' AS agency,
    'NJ0141000' AS ori,
    coalesce(ST_Y(location), 0) AS latitude,
    coalesce(ST_X(location), 0) AS longitude,
    '' AS direction,
    '' AS imageVehicle,
    '' AS imagePlate,
    '' AS additionalImage1,
    '' AS additionalImage2,
    a.image_id,
    coalesce(a.doc->'source'->>'id', '') as source_id
    FROM alpr a join hotlists h on a.plate_num = h.plate_number
  where a.id = $1::bigint and h.id = $2::bigint
`

type GetPlateHitParams struct {
	PlateID   int64 `json:"plateID"`
	HotlistID int64 `json:"hotlistID"`
}

type GetPlateHitRow struct {
	ID               string           `json:"id"`
	Eventid          string           `json:"eventid"`
	Eventdatetime    pgtype.Timestamp `json:"eventdatetime"`
	Platenumber      string           `json:"platenumber"`
	Platest          pgtype.Text      `json:"platest"`
	Platenumber2     string           `json:"platenumber2"`
	Confidence       string           `json:"confidence"`
	Vehiclemake      pgtype.Text      `json:"vehiclemake"`
	Vehiclemodel     string           `json:"vehiclemodel"`
	Vehiclecolor     pgtype.Text      `json:"vehiclecolor"`
	Vehiclesize      string           `json:"vehiclesize"`
	Vehicletype      pgtype.Text      `json:"vehicletype"`
	Cameraid         string           `json:"cameraid"`
	Cameraname       pgtype.Text      `json:"cameraname"`
	Cameratype       string           `json:"cameratype"`
	Agency           string           `json:"agency"`
	Ori              string           `json:"ori"`
	Latitude         interface{}      `json:"latitude"`
	Longitude        interface{}      `json:"longitude"`
	Direction        string           `json:"direction"`
	Imagevehicle     string           `json:"imagevehicle"`
	Imageplate       string           `json:"imageplate"`
	Additionalimage1 string           `json:"additionalimage1"`
	Additionalimage2 string           `json:"additionalimage2"`
	ImageID          pgtype.Text      `json:"imageID"`
	SourceID         interface{}      `json:"sourceID"`
}

func (q *Queries) GetPlateHit(ctx context.Context, arg GetPlateHitParams) ([]GetPlateHitRow, error) {
	rows, err := q.db.Query(ctx, getPlateHit, arg.PlateID, arg.HotlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlateHitRow{}
	for rows.Next() {
		var i GetPlateHitRow
		if err := rows.Scan(
			&i.ID,
			&i.Eventid,
			&i.Eventdatetime,
			&i.Platenumber,
			&i.Platest,
			&i.Platenumber2,
			&i.Confidence,
			&i.Vehiclemake,
			&i.Vehiclemodel,
			&i.Vehiclecolor,
			&i.Vehiclesize,
			&i.Vehicletype,
			&i.Cameraid,
			&i.Cameraname,
			&i.Cameratype,
			&i.Agency,
			&i.Ori,
			&i.Latitude,
			&i.Longitude,
			&i.Direction,
			&i.Imagevehicle,
			&i.Imageplate,
			&i.Additionalimage1,
			&i.Additionalimage2,
			&i.ImageID,
			&i.SourceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ingestALPR = `-- name: IngestALPR :one
select alpr_util.ingest_alpr($1::jsonb) as result
`

func (q *Queries) IngestALPR(ctx context.Context, doc []byte) (string, error) {
	row := q.db.QueryRow(ctx, ingestALPR, doc)
	var result string
	err := row.Scan(&result)
	return result, err
}

const insertHotlist = `-- name: InsertHotlist :one
select alpr_util.hotlists_upsert_pois($1::jsonb) as added
`

func (q *Queries) InsertHotlist(ctx context.Context, doc []byte) (int32, error) {
	row := q.db.QueryRow(ctx, insertHotlist, doc)
	var added int32
	err := row.Scan(&added)
	return added, err
}

const nextWake = `-- name: NextWake :one



select alpr_util.next_wake()
`

// SELECT
//
//	t.id::bigint as id,
//	t.plate_id::bigint as plate_id,
//	t.hotlist_id::bigint as hotlist_id
//
// FROM alpr_util.claim_due(@batch::integer , @worker_id::text) AS t(id bigint, plate_id bigint, hotlist_id bigint);
func (q *Queries) NextWake(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, nextWake)
	var next_wake interface{}
	err := row.Scan(&next_wake)
	return next_wake, err
}

const reclaimStuck = `-- name: ReclaimStuck :one
select alpr_util.alerts_reclaim_stuck()
`

func (q *Queries) ReclaimStuck(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, reclaimStuck)
	var alerts_reclaim_stuck int32
	err := row.Scan(&alerts_reclaim_stuck)
	return alerts_reclaim_stuck, err
}

const scheduleFailure = `-- name: ScheduleFailure :exec
select alpr_util.hostlist_alert_schedure_failure($1, $2)
`

type ScheduleFailureParams struct {
	ID  interface{} `json:"id"`
	Err interface{} `json:"err"`
}

func (q *Queries) ScheduleFailure(ctx context.Context, arg ScheduleFailureParams) error {
	_, err := q.db.Exec(ctx, scheduleFailure, arg.ID, arg.Err)
	return err
}

const scheduleSuccess = `-- name: ScheduleSuccess :exec
select alpr_util.hotlist_alert_schedule_success($1)
`

func (q *Queries) ScheduleSuccess(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, scheduleSuccess, id)
	return err
}
